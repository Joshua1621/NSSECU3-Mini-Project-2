#!/usr/bin/env python3
"""
mp2_malware_scanner.py

Scans drives/paths for files matching the signatures generated from the dataset.
Detection is based on file size (Â±50) and a unique byte prefix.
MD5 and SHA1 are computed only for output (not used in detection).

Usage:
  python mp2_malware_scanner.py [--signatures FILE] [paths ...]
If no paths are given, all available drives are scanned.
"""

import os
import sys
import csv
import json
import hashlib
import argparse
import string


def get_available_drives():
    """Return list of existing Windows drives (e.g., ['C:\\', 'D:\\'])."""
    drives = []
    for letter in string.ascii_uppercase:
        drive = f"{letter}:\\"
        if os.path.exists(drive):
            drives.append(drive)
    return drives


def count_files(root_paths):
    """First pass: count total files for progress percentage."""
    total = 0
    for path in root_paths:
        for root, dirs, files in os.walk(path, followlinks=False):
            total += len(files)
    return total


def compute_hashes(filepath, chunk_size=8192):
    """Compute MD5 and SHA1 of a file using chunked reading."""
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    try:
        with open(filepath, 'rb') as f:
            while True:
                chunk = f.read(chunk_size)
                if not chunk:
                    break
                md5.update(chunk)
                sha1.update(chunk)
        return md5.hexdigest(), sha1.hexdigest()
    except (IOError, OSError, PermissionError):
        return None, None


def main():
    parser = argparse.ArgumentParser(
        description="Scan for files matching dataset signatures."
    )
    parser.add_argument(
        "--signatures", "-s",
        default="file_signatures.json",
        help="Path to the signature file (default: file_signatures.json)"
    )
    parser.add_argument(
        "paths", nargs="*",
        help="Specific directories or drives to scan (default: all available drives)"
    )
    args = parser.parse_args()

    # 1. Load signatures
    try:
        with open(args.signatures, 'r') as f:
            signatures = json.load(f)
    except Exception as e:
        print(f"Error loading signature file: {e}", file=sys.stderr)
        sys.exit(1)

    if not signatures:
        print("No signatures loaded. Exiting.", file=sys.stderr)
        sys.exit(1)

    # 2. Determine scan roots
    scan_roots = args.paths if args.paths else get_available_drives()
    if not scan_roots:
        print("No valid paths to scan. Exiting.", file=sys.stderr)
        sys.exit(1)

    print(f"Scan roots: {scan_roots}")
    print("Counting files...")
    total_files = count_files(scan_roots)
    print(f"Total files to process: {total_files}")

    # 3. Prepare for scanning
    max_prefix_len = max(sig["prefix_len"] for sig in signatures)
    results = []
    processed = 0
    matched = 0

    # 4. Scan
    print("Starting scan...")
    for root_path in scan_roots:
        for current_root, dirs, files in os.walk(root_path, followlinks=False):
            for file in files:
                processed += 1
                filepath = os.path.join(current_root, file)

                # Progress update
                if processed % 100 == 0 or processed == total_files:
                    percent = (processed / total_files) * 100 if total_files else 0
                    print(f"\rProcessed: {processed}/{total_files} ({percent:.1f}%) | "
                          f"Matches: {matched}", end='')

                # Get file size
                try:
                    size = os.path.getsize(filepath)
                except (OSError, PermissionError):
                    continue

                # Read first max_prefix_len bytes
                try:
                    with open(filepath, 'rb') as f:
                        header = f.read(max_prefix_len)
                except (IOError, OSError, PermissionError):
                    continue

                # Check against each signature
                for sig in signatures:
                    # Size check
                    if size < sig["size_min"] or size > sig["size_max"]:
                        continue
                    # Prefix length check
                    prefix_len = sig["prefix_len"]
                    if len(header) < prefix_len:
                        continue
                    # Prefix match
                    if header[:prefix_len].hex().upper() == sig["prefix_hex"]:
                        matched += 1
                        # Compute hashes for output (not used in detection)
                        md5, sha1 = compute_hashes(filepath)
                        if md5 is None:
                            md5 = ""
                        if sha1 is None:
                            sha1 = ""
                        # Get first 50 bytes for reporting (if available)
                        if len(header) >= 50:
                            first_50 = header[:50].hex().upper()
                        else:
                            first_50 = header.hex().upper()
                        results.append([
                            file,                     # File Name
                            md5,                      # Hash MD5
                            sha1,                     # Hash SHA1
                            current_root,             # Directory Found
                            "UNKNOWN",                # File Type (can be added later)
                            first_50,                  # First 50 bytes hex
                            "signature"                # Detection Method
                        ])
                        break  # A file should match only one signature

    print()  # newline after progress

    # 5. Write CSV
    output_file = "MP2_Scan_Results.csv"
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow([
            "File Name", "Hash MD5", "Hash SHA1",
            "Directory Found", "File Type", "First 50-bytes Magic Numbers",
            "Detection Method"
        ])
        writer.writerows(results)

    print(f"Scan complete. Matched {matched} files.")
    print(f"Results written to {output_file}")


if __name__ == "__main__":
    main()